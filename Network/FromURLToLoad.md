# 从输入URL到页面加载发生了什么

具体来说有以下几个过程：

    1. DNS 解析
    2. TCP 连接
    3. 发送 http 连接
    4. 服务器处理请求并返回 HTTP 报文
    5. 浏览器渲染解析页面
    6. 连接结束

## DNS 解析

DNS 解析的过程就是一个网址到 IP 地址的转换。

### 解析过程

DNS 解析是一个递归查询的过程。

首先在本地域名服务器中查询 IP 地址。没有找到的情况下，本地域名服务器回向根域名服务器发送一个请求；如果没有找到的话，会向 com 顶级域名服务器发送一个请求，以此类推下去。知道最后本地域名服务器得到 google 的地址并把它缓存到本地，以供下次查询使用。

网址的解析是一个从右到左的过程：. -> com -> google.com -> www.google.com

### DNS 优化

#### DNS 缓存

从离浏览器的具体排序的话，有以下几种，**浏览器缓存**，**系统缓存**，**路由器缓存**，**IPS 服务器缓存**，**根域名服务器缓存**，**顶级域名服务器缓存**，**主域名服务器缓存**。

#### DNS 均衡负载

利用 DNS 的重定向技术，DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点服务器负责响应用户的请求，提供所需的内容。DNS 可以返回一个合适的机器的 IP 给用户，例如根据每台机器的负载量，改机器离用户地理位置的距离等等。

### TCP连接

HTTP 协议是使用 TCP 作为其传输层协议的，当 TCP 出现瓶颈时，HTTP 也会受到影响。

1. HTTP： IP -> TCP -> HTTP
2. HTTPS: IP -> TCP -> SSL/TLS -> HTTP

TCP 是面向连接的运输层，提供可靠交付的，全双工的，面向字节流的点对点服务。HTTP 协议便是基于 TCP 协议实现的。虽然作为应用层协议，HTTP 协议并没有明确要求使用 TCP 协议作为运输层协议。但是因为 HTTP 协议对可靠性的要求，默认 HTTP 是基于 TCP 协议的。使用 UDP 这种不可靠保障机制等功能就必须全部放到应用层来事项。相比于网络层，运输层着眼于应用进程间的通信，而不是网络层的主机间的通讯。

端口代表主机上的一个应用进程，而套接字则是 ip 地址与端口号的合体，可以在网络上范围内唯一确定一个应用进程。

seq（序号）: TCP 连接字节流中每一个字节都会有一个编号，二本字段的值指的是本报文段所发送数据部分第一个字节的序号。
ack（确认号）: 表示期望收到的下一个报文段数据部分的第一个字节的编号，编号为 ack-1 及以前的字节已经收到。
SYN: 仅当本字段为 1 时，表示这是一个连接请求或者连接接受报文。
ACK: 仅当本字段为 1 时，确认号才有效
FIN: 用来释放一个连接，当本字段为 1 时，表示此报文段的发送端数据已经发送完毕，要求释放运输连接。

#### TCP 的运输连接管理

三个阶段：连接建立，数据传送以及连接释放。

**连接建立阶段：**

1. 第一次握手：客户端的应用进程主动打开，并向服务器发送请求报文段。其首部中：SYN=1,seq=x
2. 第二次握手：服务器应用进程被动打开，若同意客户端的请求，则发回确认报文，其首部中：ACK=1,SYN=1,ack=x+1,seq=y
3. 第三次握手：客户端确认报文之后，通知上层应用进程连接已建立，并向服务器发送确认报文，其首部：ACK=1,ack=y+1。当服务器收到客户端的确认报文后，也通知其上层应用进程连接已建立。

**连接释放阶段：**

1. 第一次挥手：数据传输结束以后，客户端的应用进程发出连接释放报文段，并停止发送数据，其首部：FIN=1,seq=u
2. 第二次挥手：服务器端收到连接释放报文之后，发送确认报文，其首部为：ACK=1,ack=u+1,seq=v；此时本次连接就进入了半关闭的状态，客户端不再向服务器发送数据。服务器端仍会继续发送。
3. 第三次挥手：若服务器已经没有要向客户端发送的数据，其应用进程就通知服务器释放 TCP 连接。这个阶段服务器所发出的最后一个报文的首部为：FIN=1,ack=u+1,seq=w,ACK=1
4. 第四次挥手：客户端接收连接释放报文段之后，必须发出确认：ACK=1.ack=w+1,seq=u+1。再经过 2MSL(最长报文端寿命)后，本次 TCP 连接真正结束，通信双方完成了他们之间的告别

*在结束连接的过程中，为什么在收到服务器端的连接释放报文段之后，客户端还要继续等待 2MSL 之后才真正的关闭 TCP 连接呢？*

- 确保服务器收到了客户端的最后一条确认报文。假如这条报文丢失，服务器没有接收到确认报文，就会对连接释放的报文进行重传，而此时客户端连接已关闭，无法做出响应，就造成了服务器不停重传连接释放报文，而无法正常进入关闭状态的状况。**而等待 2MSL，就可以保证服务器端收到了最终确认；若服务器没有收到，那么在 2MSL 之内客户端一定会收到服务器端的重传报文，此时客户端就会重传确认报文，并重置计时器**
- 存在一种“已失效的连接请求报文段”，需要避免这种报文出现在本连接中，造成异常。这种“已失效的连接请求报文段”是这么形成的：假如客户端发出了连接请求，然而服务器端没有收到，于是客户端进行超时重传，再一次发送了连接请求报文，并成功建立连接。然而，第一次发送的连接请求报文并没有丢失，只是在某个网络结点中发生了长时间滞留，随后，这个最初发送的报文段到达服务器端，会使得服务器端误以为客户端发出了新的请求，造成异常。

### HTTPS 请求

HTTPS 在传输数据之间需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL 使用了非对称加密，对称加密以及 hash 等。

1. 客户端给出协议版本号，一个客户端生成的随机数（Client random），以及客户端支持的加密方法
2. 服务器端确认双方使用的加密方法，并给出数字证书，以及一个服务器生成的随机数（Server random）。
3. 客户端确认证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发送给服务器端。
4. 服务器使用自己的私钥，获取客户端发来的随机数（即 Premaster secret）。
5. 客户端和服务器端根据约定的加密方法，使用前面的三个随机数，生成“对话密钥”(session key)，用来加密接下来的整个对话过程。

#### 私钥的作用

- 生成对话密钥一共需要三个随机数
- 握手之后的对话使用“对话密钥”加密(对称加密)，服务器的公钥和私钥只用于加密和解密“对话密钥”（非对称加密），无其他作用。
- 服务器公钥放在服务器的数字证书之中。

#### session 的恢复

1. session ID
    每次对话都有一个编号(session ID)。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的“对话密钥”，而不必重新生成一把。
    session ID 是目前所有浏览器都支持的方法，但是他的缺点在于 session ID 往往只保留在一台服务器上
2. session ticket
    客户端不再发送 session ID，而是发送一个服务器在上一次对话中发送过来的 session ticket。这个 session ticket 是加密的，只有服务器才能解密。当服务器收到 session ticket 以后，解密后就不必重新生成对话密钥了。




























参考链接:
[简述TCP连接的建立与释放](https://zhuanlan.zhihu.com/p/24860403)
[从输入URL到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)
[TCP 的特性](https://hit-alibaba.github.io/interview/basic/network/TCP.html)
[图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
