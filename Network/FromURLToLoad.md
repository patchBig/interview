# 从输入URL到页面加载发生了什么

具体来说有以下几个过程：

    1. DNS 解析
    2. TCP 连接
    3. 发送 http 连接
    4. 服务器处理请求并返回 HTTP 报文
    5. 浏览器渲染解析页面
    6. 连接结束

## DNS 解析

DNS 解析的过程就是一个网址到 IP 地址的转换。

### 解析过程

DNS 解析是一个递归查询的过程。

首先在本地域名服务器中查询 IP 地址。没有找到的情况下，本地域名服务器回向根域名服务器发送一个请求；如果没有找到的话，会向 com 顶级域名服务器发送一个请求，以此类推下去。知道最后本地域名服务器得到 google 的地址并把它缓存到本地，以供下次查询使用。

网址的解析是一个从右到左的过程：. -> com -> google.com -> www.google.com

### DNS 优化

#### DNS 缓存

从离浏览器的具体排序的话，有以下几种，**浏览器缓存**，**系统缓存**，**路由器缓存**，**IPS 服务器缓存**，**根域名服务器缓存**，**顶级域名服务器缓存**，**主域名服务器缓存**。

#### DNS 均衡负载

利用 DNS 的重定向技术，DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点服务器负责响应用户的请求，提供所需的内容。DNS 可以返回一个合适的机器的 IP 给用户，例如根据每台机器的负载量，改机器离用户地理位置的距离等等。

### TCP连接

HTTP 协议是使用 TCP 作为其传输层协议的，当 TCP 出现瓶颈时，HTTP 也会受到影响。

1. HTTP： IP -> TCP -> HTTP
2. HTTPS: IP -> TCP -> SSL/TLS -> HTTP

TCP 是面向连接的运输层，提供可靠交付的，全双工的，面向字节流的点对点服务。HTTP 协议便是基于 TCP 协议实现的。虽然作为应用层协议，HTTP 协议并没有明确要求使用 TCP 协议作为运输层协议。但是因为 HTTP 协议对可靠性的要求，默认 HTTP 是基于 TCP 协议的。使用 UDP 这种不可靠保障机制等功能就必须全部放到应用层来事项。相比于网络层，运输层着眼于应用进程间的通信，而不是网络层的主机间的通讯。

端口代表主机上的一个应用进程，而套接字则是 ip 地址与端口号的合体，可以在网络上范围内唯一确定一个应用进程。

seq（序号）: TCP 连接字节流中每一个字节都会有一个编号，二本字段的值指的是本报文段所发送数据部分第一个字节的序号。
ack（确认号）: 表示期望收到的下一个报文段数据部分的第一个字节的编号，编号为 ack-1 及以前的字节已经收到。
SYN: 仅当本字段为 1 时，表示这是一个连接请求或者连接接受报文。
ACK: 仅当本字段为 1 时，确认号才有效
FIN: 用来释放一个连接，当本字段为 1 时，表示此报文段的发送端数据已经发送完毕，要求释放运输连接。

#### TCP 的运输连接管理

三个阶段：连接建立，数据传送以及连接释放。

**连接建立阶段：**

1. 第一次握手：客户端的应用进程主动打开，并向服务器发送请求报文段。其首部中：SYN=1,seq=x
2. 第二次握手：服务器应用进程被动打开，若同意客户端的请求，则发回确认报文，其首部中：ACK=1,SYN=1,ack=x+1,seq=y
3. 第三次握手：客户端确认报文之后，通知上层应用进程连接已建立，并向服务器发送确认报文，其首部：ACK=1,ack=y+1。当服务器收到客户端的确认报文后，也通知其上层应用进程连接已建立。

**连接释放阶段：**

1. 第一次挥手：数据传输结束以后，客户端的应用进程发出连接释放报文段，并停止发送数据，其首部：FIN=1,seq=u
2. 第二次挥手：服务器端收到连接释放报文之后，发送确认报文，其首部为：ACK=1,ack=u+1,seq=v；此时本次连接就进入了半关闭的状态，客户端不再向服务器发送数据。服务器端仍会继续发送。
3. 第三次挥手：若服务器已经没有要向客户端发送的数据，其应用进程就通知服务器释放 TCP 连接。这个阶段服务器所发出的最后一个报文的首部为：FIN=1,ack=u+1,seq=w,ACK=1
4. 第四次挥手：客户端接收连接释放报文段之后，必须发出确认：ACK=1.ack=w+1,seq=u+1。再经过 2MSL(最长报文端寿命)后，本次 TCP 连接真正结束，通信双方完成了他们之间的告别

*在结束连接的过程中，为什么在收到服务器端的连接释放报文段之后，客户端还要继续等待 2MSL 之后才真正的关闭 TCP 连接呢？*

- 确保服务器收到了客户端的最后一条确认报文。假如这条报文丢失，服务器没有接收到确认报文，就会对连接释放的报文进行重传，而此时客户端连接已关闭，无法做出响应，就造成了服务器不停重传连接释放报文，而无法正常进入关闭状态的状况。**而等待 2MSL，就可以保证服务器端收到了最终确认；若服务器没有收到，那么在 2MSL 之内客户端一定会收到服务器端的重传报文，此时客户端就会重传确认报文，并重置计时器**
- 存在一种“已失效的连接请求报文段”，需要避免这种报文出现在本连接中，造成异常。这种“已失效的连接请求报文段”是这么形成的：假如客户端发出了连接请求，然而服务器端没有收到，于是客户端进行超时重传，再一次发送了连接请求报文，并成功建立连接。然而，第一次发送的连接请求报文并没有丢失，只是在某个网络结点中发生了长时间滞留，随后，这个最初发送的报文段到达服务器端，会使得服务器端误以为客户端发出了新的请求，造成异常。

### HTTPS 请求

HTTPS 在传输数据之间需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL 使用了非对称加密，对称加密以及 hash 等。

1. 客户端给出协议版本号，一个客户端生成的随机数（Client random），以及客户端支持的加密方法
2. 服务器端确认双方使用的加密方法，并给出数字证书，以及一个服务器生成的随机数（Server random）。
3. 客户端确认证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发送给服务器端。
4. 服务器使用自己的私钥，获取客户端发来的随机数（即 Premaster secret）。
5. 客户端和服务器端根据约定的加密方法，使用前面的三个随机数，生成“对话密钥”(session key)，用来加密接下来的整个对话过程。

#### 私钥的作用

- 生成对话密钥一共需要三个随机数
- 握手之后的对话使用“对话密钥”加密(对称加密)，服务器的公钥和私钥只用于加密和解密“对话密钥”（非对称加密），无其他作用。
- 服务器公钥放在服务器的数字证书之中。

#### session 的恢复

1. session ID
    每次对话都有一个编号(session ID)。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的“对话密钥”，而不必重新生成一把。
    session ID 是目前所有浏览器都支持的方法，但是他的缺点在于 session ID 往往只保留在一台服务器上
2. session ticket
    客户端不再发送 session ID，而是发送一个服务器在上一次对话中发送过来的 session ticket。这个 session ticket 是加密的，只有服务器才能解密。当服务器收到 session ticket 以后，解密后就不必重新生成对话密钥了。

#### GET 和 POST有什么区别

- GET

    读取一个资源，比如 get 一个 HTML 文件，反复读取不应该有对访问数据有副作用。没有副作用被称为“幂等”。
    因为是 GET 是读取的操作，可以对其进行缓存，这个缓存可以做到浏览器上（彻底避免浏览器发送请求），也可以做到代理上（如 nginx）或者 server 端（用 Etag，至少可以减少宽带消耗）

- POST

    页面里面的 form 表单点击 submit 会发出一个 post 请求让服务器做一件事情，这件事情往往是有副作用的，不幂等的。

GET 和 POST 携带数据的格式也有区别。其实并不是 GET 只能用 URL，而是浏览器直接发出的 GET 只能由一个 URL 触发，所以 GET 上要在 URL 之外带一些参数就只能依靠 URL 上附带 querystring，但是 HTTP 协议本身没有这个限制。
浏览器的 post 请求都来自于表单提交。每次提交，表单的数据被浏览器用编码到 HTTP 请求的 body 里。浏览器发出的 post 请求的 body 有两种格式 application/x-www-form-urlencoded 用来传输简单的数据，大概就是 "key1=value1&key2=value2"这样的格式。另外一种是传文件，会采用 multipart/form-data 格式。采用后者是因为 application/x-www-form-urlencoded 的编码方式对于文件这种二进制的数据非常低效。

##### REST POST 和 REST PUT

PUT 的实际语义是 replace。rest 规范里面提到的请求提应该是完整的资源，包括 id 在内。服务器应该是先根据请求提供的 id 进行查找。如果存在一个对应 id 的元素。就用请求中的数据整体替换已经存在的资源；如果没有，就用这个 id 对应的资源从【空】替换为 【请求数据】。直观看起来就是创建了。
POST 是通过一组必要的数据创建出完整的资源。至于到底用 PUT 还是 POST 创建资源。完全要看是不是提前可以知道资源所有的数据。以及是不是完整替换。当想上传一个新资源的时候，其 id 是可以提前知道，同事这个 api 也总是完整的 replace 整个资源。这时的 api 用 PUT 的语义更合适。而对于 id 是服务器自动生成的场景，post 更合适一些。

##### 关于安全性

无论是 GET 还是 POST 都不够安全，因为 HTTP 本身是明文协议。每个 http 请求和返回的每个 byte 都会在网络上传播，不管是 url，header 还是 body。

GET 不安全的原因：携带的私密信息的 url 会在地址栏上，还可以分享给第三方，就非常不安全了。此外，从客户端到服务器端，有大量的中间节点，包括网关、代理等。，他们的 access log 通常会输出完整的 url，比如 nginx 的默认 access log 就是如此。如果 url 上携带敏感数据，就会被记录下来。**就算私密数据在 body 里面，也是可以被记录下来的。**避免泄密的唯一手段就是  https。

##### 关于编码

GET 和 POST 都能用 url 和 body。确切的来说应该是 http 中 url 用什么编码，body 用什么编码。

url 只能支持 ASCII 的说法源于[RFC1738](https://www.ietf.org/rfc/rfc1738.txt)。
实际上这里的规定的仅仅是 ASCII 的子集[a-zA-Z0-9$-_.+!*'(),]。他们是可以”不经编码“在 url 中使用的。比如尽管空格也是 ASCII 字符，但是不能直接在 url 中使用。

HTTP Body 相对好些，因为有个 Content-Type 来比较明确的定义。这里 Content-Type 会同时定义请求 body 的格式（application/x-www-form-urlencoded）和字符编码（utf-8）。

POST 请求就是表单提交，而表单提交只有 application/x-www-form-urlencoded。
针对简单的 key-value 场景；和 multipart/form-data。

##### 浏览器的 POST 需要发两个请求吗

客户端可以利用 HTTP 的 continued 协议来这样做：客户端总是先发送所有请求头给服务器，让服务器校验，如果通过了，服务器恢复 "100-continue"，客户端再把剩下的数据发送服务器。如果请求被拒了，服务器就回复个 400 之类的错误。交互就终止了。这样就避免浪费带宽传请求体。但是代价就是会多一次 round trip。如果刚好请求体的数据也不多，那么一次性全部发送给服务器可能反而更好。

基于此，客户端就能做一些优化，比如内部设定一次 POST 的数据超过 1KB 就先只发送“请求头”，否则就一次性全发。客户端甚至可以做一些 Adaptive 的策略。统计发送成功率，如果成功率很高，就总是全部发等等。不同浏览器，不同的客户端（curl, postman)可以有各自的不停的方案。不管怎样做，优化目的总是提高数据吞吐量和降低带宽做一个折衷。

##### 请求报头

Accept 用于指定客户端用于接受哪些类型的信息，Accept-Encoding 与 Accept 类似，它用于指定接受的编码方式。Connection 设置为 keep-alive 用于告诉客户端本次 HTTP 请求之后并不需要关闭 TCP 连接，这样可以使下次 HTTP 请求使用相同的 TCP 通道，节省 TCP 连接建立的时间。

##### 状态码

- 1xx：信息响应
- 2xx：成功响应
- 3xx：重定向–要完成请求必须进行更进一步的操作
- 4xx：客户端错误–请求有语法错误或请求无法实现
- 5xx：服务器端错误–服务器未能实现合法的请求

| 状态码 | 意义 |
|:----: | :-------: |
| 100 | Continue 继续, 客户端应继续其请求|
| 204 | No Content 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息 |
| 301 | Moved Permanently永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替|
| 302 | Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有 URI|
| 304 | Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源|
| 400 Bad Request | 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
2、请求参数有误。|
| 401 Unauthorized | 当前请求需要用户验证。 |
| 403 Forbidden | 服务器已经理解请求，但是拒绝执行它 |
| 404  Not Found | 请求失败，请求所希望得到的资源未被在服务器上发现 |
| 422 Unprocessable Entity | 请求格式良好，但由于语义错误而无法遵循。 |
| 500 Internal Server Error | 服务器遇到了不知道如何处理的情况。 |

##### HTTP 缓存

重用已获取的资源能够有效的提升网站与应用的性能。Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。

缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 Web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处是：缓解服务器端压力，提升性能。对于网站来说，缓存是到达高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的，重要的是对一个资源的缓存应截止到其下一次发生改变。

缓存的种类有很多，其大致可以归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。

###### 缓存控制

> cache-control 头

1. 禁止进行缓存 Cache-control: no-store
缓存中不得存储任何关于客户端请求和服务器响应的内容。每次都由客户端发起的请求都会下载完整的响应内容。

2. 强制确认缓存 Cache-Control: no-cache
每次有请求发出时，缓存会将此请求发到服务器（该请求应该会带有本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（实际就是返回 304），则缓存才使用本地缓存副本。

3. 私有缓存与公共缓存 Cache-Control: private Cache-Control: public
"public" 指令表示该响应可以被任何中间人（中间代理或 CDN 等）缓存。若指定了"public"，则一些通常被中间人缓存的页面（应为默认是 private）（比如带有 HTTP 验证信息(账号密码)的页面或某些特定状态码的页面），将会被其缓存。
而 private 则表示该响应是专门用于某单个用户的，中间人不能缓存此响应，该响应只能用于浏览器私有缓存中。

4. 缓存过期机制 Cache-Control: max-age=31536000
过期机制中，最重要的指令是 "max-age=<seconds>"，表示资源能够被缓存（保持新鲜）的最大时间。相对 Expire 而言，max-age 是距离请求发起时间的秒数。针对应用中那些不会更改的文件，通常可以手动设置一定的时长已保证缓存有效。

###### 新鲜度

当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中，由于缓存只有有限的空间存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。另一方面，服务器上的资源进行了更新，那么缓存中的对应资源也应该被更新，由于 HTTP 是 C/S 模式的协议，服务器上更新一个资源时，不可能直接通知客户端更新缓存，所以双方必须为该资源约定一个过期时间，在改过期时间之前，该资源副本就是新鲜的，当过了过期时间后，该资源则变为陈旧的，算法驱逐用于将陈旧的资源替换为新鲜的。注意一个陈旧的资源是不会被直接清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧的资源，则缓存就会先此请求附加上一个 If-None-Match 头，然后发给目标服务器，以此来检查资源副本是否是依然新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since 判断后发现已过期，那么会带有该资源的实体内容返回。

##### 浏览器解析渲染页面

The browser parses out the HTML source code (tag soup) and constructs a DOM tree - a data representation where every HTML tag has a corresponding node in the tree and text chunks between tags get a text node representation too. The node in the DOM tree is the documentElement (the <html> tag).







参考链接:
[从输入URL到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)
[http 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)
[简述TCP连接的建立与释放](https://zhuanlan.zhihu.com/p/24860403)
[TCP 的特性](https://hit-alibaba.github.io/interview/basic/network/TCP.html)
[图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
[socket连接和http连接的区别](https://blog.csdn.net/wwd0501/article/details/52412396)
[WebSocket 是什么原理？为什么可以实现持久连接？](https://www.zhihu.com/question/20215561)
[GET 和 POST 到底有什么区别？](https://www.zhihu.com/question/28586791)
[http 状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)
