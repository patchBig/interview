### TCP连接

HTTP 协议是使用 TCP 作为其传输层协议的，当 TCP 出现瓶颈时，HTTP 也会受到影响。

1. HTTP： IP -> TCP -> HTTP
2. HTTPS: IP -> TCP -> SSL/TLS -> HTTP

TCP 是面向连接的运输层，提供可靠交付的，全双工的，面向字节流的点对点服务。HTTP 协议便是基于 TCP 协议实现的。虽然作为应用层协议，HTTP 协议并没有明确要求使用 TCP 协议作为运输层协议。但是因为 HTTP 协议对可靠性的要求，默认 HTTP 是基于 TCP 协议的。使用 UDP 这种不可靠保障机制等功能就必须全部放到应用层来事项。相比于网络层，运输层着眼于应用进程间的通信，而不是网络层的主机间的通讯。

端口代表主机上的一个应用进程，而套接字则是 ip 地址与端口号的合体，可以在网络上范围内唯一确定一个应用进程。

seq（序号）: TCP 连接字节流中每一个字节都会有一个编号，二本字段的值指的是本报文段所发送数据部分第一个字节的序号。
ack（确认号）: 表示期望收到的下一个报文段数据部分的第一个字节的编号，编号为 ack-1 及以前的字节已经收到。
SYN: 仅当本字段为 1 时，表示这是一个连接请求或者连接接受报文。
ACK: 仅当本字段为 1 时，确认号才有效
FIN: 用来释放一个连接，当本字段为 1 时，表示此报文段的发送端数据已经发送完毕，要求释放运输连接。

#### TCP 的运输连接管理

三个阶段：连接建立，数据传送以及连接释放。

**连接建立阶段：**

1. 第一次握手：客户端的应用进程主动打开，并向服务器发送请求报文段。其首部中：SYN=1,seq=x
2. 第二次握手：服务器应用进程被动打开，若同意客户端的请求，则发回确认报文，其首部中：ACK=1,SYN=1,ack=x+1,seq=y
3. 第三次握手：客户端确认报文之后，通知上层应用进程连接已建立，并向服务器发送确认报文，其首部：ACK=1,ack=y+1。当服务器收到客户端的确认报文后，也通知其上层应用进程连接已建立。

**连接释放阶段：**

1. 第一次挥手：数据传输结束以后，客户端的应用进程发出连接释放报文段，并停止发送数据，其首部：FIN=1,seq=u
2. 第二次挥手：服务器端收到连接释放报文之后，发送确认报文，其首部为：ACK=1,ack=u+1,seq=v；此时本次连接就进入了半关闭的状态，客户端不再向服务器发送数据。服务器端仍会继续发送。
3. 第三次挥手：若服务器已经没有要向客户端发送的数据，其应用进程就通知服务器释放 TCP 连接。这个阶段服务器所发出的最后一个报文的首部为：FIN=1,ack=u+1,seq=w,ACK=1
4. 第四次挥手：客户端接收连接释放报文段之后，必须发出确认：ACK=1.ack=w+1,seq=u+1。再经过 2MSL(最长报文端寿命)后，本次 TCP 连接真正结束，通信双方完成了他们之间的告别

*在结束连接的过程中，为什么在收到服务器端的连接释放报文段之后，客户端还要继续等待 2MSL 之后才真正的关闭 TCP 连接呢？*

- 确保服务器收到了客户端的最后一条确认报文。假如这条报文丢失，服务器没有接收到确认报文，就会对连接释放的报文进行重传，而此时客户端连接已关闭，无法做出响应，就造成了服务器不停重传连接释放报文，而无法正常进入关闭状态的状况。**而等待 2MSL，就可以保证服务器端收到了最终确认；若服务器没有收到，那么在 2MSL 之内客户端一定会收到服务器端的重传报文，此时客户端就会重传确认报文，并重置计时器**
- 存在一种“已失效的连接请求报文段”，需要避免这种报文出现在本连接中，造成异常。这种“已失效的连接请求报文段”是这么形成的：假如客户端发出了连接请求，然而服务器端没有收到，于是客户端进行超时重传，再一次发送了连接请求报文，并成功建立连接。然而，第一次发送的连接请求报文并没有丢失，只是在某个网络结点中发生了长时间滞留，随后，这个最初发送的报文段到达服务器端，会使得服务器端误以为客户端发出了新的请求，造成异常。