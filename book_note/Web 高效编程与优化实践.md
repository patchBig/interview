# 读书笔记

## 第二章 JS 优化

### Effective 前端 5：减少前端代码耦合

- 写代码的原则是要低耦合，高内聚。所谓的内聚就是说如果一个模块的职责功能十分紧密，不可分割，那么他就是高内聚的。
- 如果需要传递的参数比较多，这个时候就可以考虑把它封装成一个类。
- 事件还可以直接用于两个模块或者组件间的通信，当两个模块关系比较紧密，共同完成一个功能时，那么可以 require 进来，但是当两个模块功能比较独立，每个模块完成自己的功能，并且完成后需要通知另一个模块相应的做些修改，那么就可以用事件的机制通知其他模块相应的做些修改，即一个模块 trigger 一个自定义事件，另一个模块监听这个事件。
  
### Effective 前端 6：JS 书写优化

- 指明变量类型
- 函数的返回类型应该是确定的；如果类型确定，解释器也不用去做一些额外的工作，可以加快运行速度。否则可能会触发“优化回滚”，即编译器已经给这个函数编译成一个函数了，但是突然发现类型变了，有得回滚到通用的状态，然后再重新生成新的函数。

## 第三章 页面优化

- 首先用 JS 做了些逻辑，还触发了样式变化，style 把应用的样式规则计算好之后，把影响到的页面元素进行重新布局（叫做 Layout），再把它画到内存中的一个画布中，Paint 成了像素，最后吧这个画布刷新到屏幕上去，叫做 composite，形成一帧。
- 减少 Layout；能使用 transform 就不要使用 position/width/height 做动画，另外要减少 Layout 的影响范围
- 简化 DOM 结构
- 使用响应式图片 picture img source srcset media source 还可以使用 webp 格式文件
- 一个页面展示太多图片，那么页面的 onloaded 时间将会较长，并且由于并行加载资源数是有限的，图片太多会导致放在 body 后面的 JS 解析比较慢，页面将较长时间处于不可交互状态。所以不能一下子把全部图片都放出来，这对于手机上的流量也是不利的。
- 将 src 的属性写成了 "about: black"。这是因为不能随便写一个不存在的地址，否则控制台会报错：加载失败；如果写成空或者不写。就会认为 src 就是当前页面。如果写成 about: blank，大家相安无事。并且不同浏览器兼容性好。
- gzip 压缩，只需要在 Nginx 的配置里面添加 gzip on  就可以开启压缩了。
- 第一次请求的时候，Nginx 的 http 响应头里面返回了 HTML 的最近修改时间；在第二次请求的时候，浏览器会把这个 Last-Modified 带上，变成 If-Modified-Since 字段；这样 Nginx 就可以读取本地文件信息里的修改时间和这个进行比较，一旦时间一致或者在此之前，返回 304，告诉客户端从缓存中取。
- 手动控制缓存时间，就是使用 Cache-Control。max-age 的优先级要大于 last-modified。如果要强制不缓存，则把 expires 时间改成 0。
- 设置缓存的作用一个是把 200 变成 304，避免资源重新传输，第二个是让浏览器直接从缓存读取，连 http请求都不用了。
- Nginx 开启 etag 只需要在 server 配置里面加上一行， etag on。etag 就是对文件做一个校验和。第一次访问的时候，响应头里面返回这个文件的 etag，浏览器第二次访问的时候，把 etag 带上，添加在 If-None-Match 字段，Nginx 根据这个 etag 和新渲染的文件计算出的 etag 进行比较，如果相等则返回 304。由于 etag 是要使用少数的字符表示一个不定大小的文件，所以 etag 是有重合的风险的。使用 etag 的代价是增加了服务器的计算负担，特别是当文件比较大的时候。

### 用好 Chrome Devtools

- console.table 可以用来查看数组和对象，非常清爽
- console.dir 能递归打印 DOM 对象的所有属性
- 用 %c 可以在控制台打印带样式的提示语 console.log('%c 你颠三倒四 %s', 'background: #222', '>>')
- 检查没有用到的 CSS/JS；打开 devtools 的 Coverage 标签栏，没有用到的用红色表示，用到的用绿色表示；用媒体查询去加载不同的 CSS; `<link ref="stylesheet" href="large.css" media="screen and (min-width:500px)">`
- console.trace 向 Web 控制台输出一个堆栈跟踪
- F10 下一步；F8 跳到下一个断点；command + ; step into 进入函数执行；shift + command/ctrl + ; step out 跳出当前函数

## h5 优化实践

### 使用 h5 的 history 改善 ajax 列表请求

- 当用户单击前进后退按钮会触发 window.onpopstate 事件，window.history.pushState(state, title, url) 其中 state 为一个 object，用来存放当前页面的数据，title 标题没有多大的作用，url 为当前页面的 url，一旦更改这个 url，浏览器地址栏的地址也会发生变化。popState 只能建ring自己调用 push 进去的。如果不是自己 push 的，那么就不会触发 popstate 事件。

### 使用 service Worker 做一个 PWA 离线应用

- 先注册一个 Worker，然后后台就会启动一条线程，可以在这条线程启动的时候去加载一些资源缓存起来，然后监听 fetch 事件，在这个事件里拦截页面的请求，先看下缓存是否有，如果有直接返回，否则正常加载。或者一开始不缓存，每个资源请求后再拷贝一份缓存起来，然后下一次请求的时候缓存里就有了。
- Service Worker 和 Cookie 一样是有 Path 路径概念的，如果设定一个 cookie 为time 的 path=/page/A，在 /page/B 这个页面是不能获取到这个 cookie 的，如果设置 cookie 的 path 为根目录 /，则所有页面都能获取到。类似的，如果注册的时候使用的 js 路径为 /page/sw.js，那么这个 Service Worker 只能管理 /page 路径下的页面和资源，而不能处理 /api 路径下，所以一般吧 Service Worker 注册到顶级目录，这样 Service Worker 就能接管页面的所有资源了。`navigator.serviceWorker.register('/sw-3.js')`

## 第五章 前端与计算机基础

### TCP 三次握手

- 向目标端口发送了一个TCP 包，带上标识位 SYN，表示要建立一个连接，并指明包开始的序列号 seq（单位为字节），以后传送的字节编号都是以这个作为起点。
- 进行回复，发送了一个 SYN + ACK 的报文段，表示同意建立连接。
- 收到 SYN 之后发送一个 ACK，同事改变接收窗口，完成三次握手。

### 接收窗口

— 它根据自身网络情况设置不同大小的值用来控制对方发送速度，避免对方发送太快，导致网络拥塞。

### 关闭连接

- 请求方觉得不用再请求数据了，于是要把连接关闭了，它向响应方发送一个 FIN 的报文。等待 30s 才关闭的是因为 HTTP 请求的 Connection: keep-alive 字段的影响，因为同一个域可能要请求多个资源，不能一个请求完了就把  连接关闭了。人如果不关闭又占用端口号资源，端口号最多只有 65535 个。
- 响应方接收后向请求方发送一个 ACK，这个时候连接出于半关闭的状态，即请求方不能向响应方发送数据了，但是响应方还可以向请求方发送。
- 响应方也要把连接关闭了，于是它向请求方发送 FIN。
- 请求方接收后，就发送 ACK，此时连接完全关闭，然后主动关闭方将进入 TIME_WAIT 状态。

### MSS 和 TIME_WAIT

- TIME_WAIT 时间为 2MSL，MSL 的意思是 Maximum Server Live-time，即报文端的最大生存时间，标准建议为2 分钟，实际实现有的为 30s。在 TIME_WAIT 状态下，上一次建立连接的套接字(socket) 将不可再重新启用，也就是同一个网卡/IP 不可再建立同样端口号的连接，如果再重新创建系统将会报错，主要是为了避免有些报文段在网络上滞留，被对方收到的时候恰好又启用了一个完全一样的套接字，那么就会被认为是这个链接的数据。
- 可以在创建 socket 的时候，指定 SO_REUSEADDR 的选项，这样就不用等待 TIME_WAIT 的时间了。
- 另外还有一个时间叫 RTT（Round Trip Time），即一个报文段的往返时间

### TCP 为什么要握手三次

- 三次握手并不能保证双方完全的信任对方，即使是四次、五次也是同样的道理，至少有一方式无法信任另一方，另外一方一想到对方可能不信它，它也会变得不信对方。

### 为什么挥手要四次

- 前两次挥手让连接出于半关闭状态，此时主动关闭方不可再向被动关闭方发送数据，而被动关闭方可继续向主动关闭方发送数据。

### 四层传输协议

- 物理层(物理帧，带上目的主机的物理地址) -> 网络层(IP/ARP，带上目的主机的 IP 地址) -> 传输层(TCP/UDP，带上目的主机的端口号) -> 应用层(HTTP、SSH、WS，最后应用层收到数据)
- 在广域网是用的 IP 地址进行报文转发，而到了局域网需要靠物理地址发送给对应的主机。IP 是点到点，负责发送到对应的主机，而 TCP 是端到端，即根据端口号，负责发送给对应的应用程序。

### Nagle 算法

- 核心思想是：等数据积累多了再一起发出去，大概等待 200 ms 这样可以提高网络的吞吐量。但是在现代，带宽和速度已经不是太大的问题，如果每个请求都要延迟 200ms，会造成实时性比较差。所以通常是要把 Nagle 算法禁止，可以在创建套接字的时候设置 TCP_NODELAY 标志位。

### Cookie

- 服务可以通过 Set-Cookie 通知客户端设置 cookie，而客户端可以用 Cookie 字段告知服务器现在的 Cookie 数据是怎么样的。

### WebSocket 连接建立

- 首先还是先建立 TCP 连接，完成后客户端发送一个 upgrade 的 HTTP 请求。
- 服务端收到后统一握手，返回 Switching Protocols，连接建立。

### Websocket 和 WebRTC

- websocket 是为了解决实时传送消息的问题，当然也可以传送数据，但是不保证传送的效率和质量，而 WebRTC 可用于可靠地传输音视频数据、文件等。并且可以建立 P2P 连接，不需要服务端进行转发数据。虚拟电话、在线面试等现在很多都是采用 WebRTC 实现。

### 理解 HTTPS 连接的前几毫秒发生了什么

- HTTPS 要解决问题就是中间人攻击。
- 域名污染，当我们访问一个域名时需要先进行域名解析，即向 DNS 服务器请求某个域名的 IP 地址。在经过 DNS 的中间链点可能会抢答，返回给你一个错误的 IP 地址，这个 IP 地址就指向中间人的机器。
- APR 欺骗，广域网的传输用的是 IP 地址，而在局域网用的是物理地址，例如路由器需要知道连接它的设备的物理地址他才可以把数据包给你，它会通过一个 ARP 的广播，向所有设备查询某个 IP 地址的物理地址是多少。

### 弄懂为什么 0.1 + 0.2 不等于 0.3

#### 反码和补码

公式：

- 正数的补码 = 反码
- 负数的补码 = 反码 + 1

> 内存中都是使用补码来计算的

用临界值的计算来举例

- -2   -> 原码 1000 0010 -> 反码 1111 1101 -> 补码 1111 1110
- -126 -> 原码 1111 1110 -> 反码 1000 0001 -> 补码 1000 0010
- 补码的运算结果：1000 0000（该类数字没有原码和补码）

##### Byte 的数据范围

- 最大的正数：0111 1111 -> 2^7 - 1 = 127
- 最大的负数：1000 0000 -> -2^7 = -128

##### 存储结构

- 单精度：符号1位，阶码8位，尾数23位
- 双精度：符号1位，阶码11位，尾数52位

##### 存储方式

一个十进制的小数在进行存储时，首先要将整数部分与小数部分都转换成二进制。然后再整理成类似科学计数法的形式，即移动小数点，使得小数点的左边只有一位，并且只可能为1（因为是二进制），*小数点右侧的部分即为尾数部分*，*移动小数点的位数将会被记录在指数部分中。*

##### 移码

- 对于绝对值大于2的数，这个时候我们向左移动小数点，对应的指数为正数
- 对于一个绝对值小于1的数，这个时候向右移动小数点，对应的指数为负数

以 float 为例，指数的长度是8，原有带符号位的 8 个 bit 的存储范围是 -128~127，也就是说可以记录 -128 次方到 127 次方之间的所有指数值。如果忽略符号位，把它也当做一个数据的存储位，那么范围就是 0~255，我们取这个数的一半作为修正值，即：127，把每次移动小数点后获取的指数值加上 127.

- 小数点向左移动3位，对应的指数为 +3，存入指数部分的值即为 130 的二进制表示
- 小数点向右移动2位，对应的指数为 -2，存入指数部分的值即为 125 的二进制表示

##### 小数在内存中的存储表示

99.9 的二进制表示：1100011.111001100110011001100110011001100110011001101。现在需要将小数点向左移动 6 位，对应的指数值为 +6。此时小数点右侧的位数为 51 位，这些将会被存放在尾数部分，如果使用 double 类型就可以将数据全部记录，但是如果使用 float 类型，由于尾数部分只有 23 位，所以只能记录部分的数据，误差也就产生了！

整理一下，符号位为 0，指数部分 6 + 127 = 133，尾数部分直接丢进去，能装多少装多少，以 float 为例，最终表示为：0 10000101 10001111100110011001100

- JS 能表示的最大整数为 Number.MAX_SAFE_INTEGER，能表示最大正数为 Number.MAX_VALUE。
计算机是使用味精致存储数据的，整数也是同样的道理，整数可以分成短整型、基本型和长整型，占用的存储空间分别为16位、32位和64位。如果操作系统是 32 位的，那么使用长整型将会慢于短整型，应为一个数它需要分两次取。
- 32 位有符号整型的存储方式，第一位 0 表示正数，1 表示负数，剩下的 31 位表示数值，所以 32 位有符号整数最大值为：2 ^ 31 - 1 = 2 147 489 647。
- 十进制的 0.75 可以表示成 7.5 \* 10 ^ -1，同样地在二进制里面，0.75 可以表示成: 0.75 = 1.1 \* 2 ^ -1
- 0.75 用二进制表示：小数部分不停乘 2，得到整数部分正序就是小数的二进制。整数部分不停除以 2，取余逆序就是整数部分的二进制。
- 如果需要更精确的表示，只需要保留更长的有效位数。这也是双精度的 double 比单精度的 float 更精确的原因。
- 浮点数存储：一个二进制浮点数存储分为三部分：1. 符号位 S 2. 指数部分 3.尾数部分

浮点数相加，需要先比较阶码是否一致，如果一致则尾数直接相加，如果不一致，需要先対阶，小阶向大阶看起，即把小阶的指数调成和大阶的一致，然后把他的尾数向右移相应的尾数。向右移以为导致尾数需要进行截断，由于最后一位刚好是 0，所以这里直接舍弃，如果是 1，那么尾数加 1，类似于十进制的四舍五入，避免误差积累。

### 为什么 JS 的最大正数是 1.79e308

这个数其实就是双精度浮点数所能表示最大正值。

```javascript
Math.pow(2, 11) - 1 - 1023
> 1024

Math.pow(2, 1024)
> 1.79e308
```

### 为什么 JS 的最大正整数不是正常的 64 位的长整型所能表示的 19 位

因为 JS 的正整数是用的尾数的长度表示的，由于尾数是 52 位，加上整数一位，他所能表示的最大的整数为：
pow(2, 53) - 1.

为什么 JS 要用这种方式呢？因为 JS 的整型和浮点型在计算过程中可以随时自动切换，整数在 JS 里面也是用浮点数的结构存储的，放在了尾数的部分。

### 怎么判断两个小数是否相等

判断两个小时是否相等要用它们的差值和一个很小的小数进行比较，如果小于这个小数，则认为两者相等，ES6 新增了一个 Math.EPSILON 属性。例如 0.1 + 0.2 是否等于 0.3 应该这么操作：

```js
0.1 + 0.2 - 0.3 < Number.EPSILON   // true
```

## 明白 WebAssembly 与程序编译

### 机器码

计算机智能运行机器码，机器码是一串二进制的数字

----

局部变量是放在栈里面的，而 new 出来是放在内存堆里面的。

### 编译和解释

在编译型语言里面，代码需要经过以下步骤转成机器码

可读文本 -(语法分析)-> 汇编语言 -(翻译)-> 可运行机器码

先把代码文本进行词法分析，语法分析，语义分析，转成汇编语言，其实解释型语言也是需要进过这些步骤的。通过词法分析识别单词，例如知道了 var 是一个关键词，people 这个单词是自定义的变量名字；语法分析把单词组成语句，例如知道了定义了一个变量，写一个赋值表达式，还有一个 for 循环；而语义分析是看逻辑合不合法，例如如果赋值给了 this 常量，编译器就会报错。
然后再把汇编翻译成机器码，汇编和机器码是两个比较接近的语言，只是汇编不需要去记住哪个数字代表哪个指令。

编译型语言需要在运行之前生成机器码，所以它的执行速度比较快，比解释性的要快若干倍，缺点是由于它生成的机器码是依赖于那个平台的，所以可执行的二进制文件无法子另一个平台运行，需要再重新编译。

相反，解释型为了达到一次书写，处处运行的目的，它不能先编译好，只能在运行的时候，根据不同的平台再一行行解释成机器码，导致运行速度要明显低于编译型语言。

### WASM 对写 JS 的提示

WASM 为什么非得是强类型的呢？因为它要转成汇编，汇编里面就得是强类型，这个对于 JS 解释器也是一样的，如果一个变量一下子是数字，一下子又变成字符串，那么解释器就得做额外的工作，例如把原本的变量销毁再创建一个新的变量，同时代码可读性也会变差。

所以提倡：

- 定义变量的时候要告诉解释器变量的类型；
- 不要随便改变变量的类型；
- 函数返回值类型是要确定的。

## 理解 JS 与多线程

### OS 的任务调度

1. 交互式进程
需要有大量的交互，如 vi 编辑器，大部分时间处于休眠状态，但是要求响应要快。
2. 批处理进程
运行在后台，如编译程序，需要占用大量的系统资源，但是可以慢点。
3. 实时进程
需要立即响应并执行，如视频播放器软件，它的优先级最高。

### 任务调度方式

- 实时进程或者说它的实时线程的优先级最高，先来先运行，直到执行完了，才执行下一个实时进程。
- 对于普通线程使用时间片轮询，每个线程分配一个时间片，当前线程用完这个时间片还没执行完，就排到当前优先级一样的线程队列的队尾。

### 线程同步

由于 Web Workers 是不可以操作 DOM 的。线程同步主要是靠锁来实现的，锁可以分成三种：

1. 互斥锁
在改变某个 DOM 元素的高度时，先把这块代码的执行给锁住了，只有执行完了才能释放这把锁，其他线程运行到这里的时候也要去申请那把锁，但是由于这把锁没有被释放，所以她就堵塞在那里了，只有等到锁被释放了，它才能拿到这把锁再继续加锁。
互斥锁使用太多会导致性能下降，因为线程堵塞在那里，它要不断地查那个锁能不能用了，所以要占用 CPU。
2. 读写锁
读写锁限制可同时读，但不可同时写。同理只要有一个线程在写，另外的线程就不能读。
3. 条件变量
条件变量是为了解决生产者和消费者的问题，由于用互斥锁和读写锁会到站i线程一直堵塞在那里占用 CPU，而使用信号通知的方式可以先让堵塞的线程进入睡眠方式，等生产者生产出东西后通知消费者，唤醒它进行消费。

### JS 没有线程同步的概念

JS 的多线程无法操作 DOM，没有 window 对象，每个线程的数据都是独立的，主线程传给子线程的数据也是通过拷贝复制，同样的子线程给主线程的数据也是通过拷贝复制，而不是共享同一块内存区域。

## 学会 JS 与面向对象

面向对象是对世界物件的抽象和封装。

### 面向对象的特点

面向对象有三个主要的特点：封装、继承和多态

#### 面向对象编程原则和设计模式

1. 单例模式

确保一个类仅有一个实例，并提供一个访问它的全局访问点

##### 不透明的，知道的人可以通过 Singleton.getInstance() 获取对象，不知道的需要研究代码

```js
// 1:
function getSingleton(name) {
  this.name = name;
  this.instance = ''
}

getSingleton.getName = function() {
  return this.name
}

getSingleton.getInstance = function(name) {
  if(!this.instance) {
    this.instance = new getSingleton(name);
  }
  return this.instance
}

// 2: 闭包的方式

function getSingleton(name) {
  this.name = name;
  this.instance = null
}

getSingleton.prototype.getName = function() {
  return this.name
}

getSingleton.prototype.getInstance = (function(){
  var instance = null
  return function(name) {
    if (!this.instance) {
      this.instance = getSingleton(name)
    }
    return instance
  }
})
```

##### 透明的

```js
function getSingleton(name) {
  this.name = name
}

getSingleton.prototype.getName = function() {
  return this.name;
}
var Singleton = (function() {
  let instance = null;
  return function(name) {
    if(!instance) {
      instance = new getSingleton(name)
    }
    return instance
  }
})
```

##### 惯性单例模式；只有当触发创建实例对象的时候，实例对象才能被创建。

```js
var getSingleton = (function(fn) {
  let instance = null
  return function() {
    return instance || (instance = fn.apply(this, arguments))
  }
})()

var  createMask = function() {
  let mask = document.createElement('div');
  mask.style.position = 'fixed'
  mask.style.top = '0'
  mask.style.left = '0'
  mask.style.bottom = '0'
  mask.style.right = '0'
  mask.style.background = '#000'
  mask.style.opacity = '0.7'
  mask.style.display = 'none'
  mask.style.zIndex = '98'
  document.body.appendChild('mask)

  mask.onClick = function() {
    this.style.display = 'none'
  }
  return mask
}

var createLogin = function() {
  // 创建div元素
  var login = document.createElement('div');
  // 设置样式
  login.style.position = 'fixed';
  login.style.top = '50%';
  login.style.left = '50%';
  login.style.zIndex = '100';
  login.style.display = 'none';
  login.style.padding = '50px 80px';
  login.style.backgroundColor = '#fff';
  login.style.border = '1px solid #ccc';
  login.style.borderRadius = '6px';

  login.innerHTML = 'login it';

  document.body.appendChild(login);

  return login;
};

document.getElementById('btn').onClick = function() {
  var mask = getSingleton(createMask)()
  mask.style.display = 'block'
  var login = getSingleton(createLogin)()
  login.style.display = 'block'
}
```
