# 读书笔记

## 第二章 JS 优化

### Effective 前端 5：减少前端代码耦合

- 写代码的原则是要低耦合，高内聚。所谓的内聚就是说如果一个模块的职责功能十分紧密，不可分割，那么他就是高内聚的。
- 如果需要传递的参数比较多，这个时候就可以考虑把它封装成一个类。
- 事件还可以直接用于两个模块或者组件间的通信，当两个模块关系比较紧密，共同完成一个功能时，那么可以 require 进来，但是当两个模块功能比较独立，每个模块完成自己的功能，并且完成后需要通知另一个模块相应的做些修改，那么就可以用事件的机制通知其他模块相应的做些修改，即一个模块 trigger 一个自定义事件，另一个模块监听这个事件。
  
### Effective 前端 6：JS 书写优化

- 指明变量类型
- 函数的返回类型应该是确定的；如果类型确定，解释器也不用去做一些额外的工作，可以加快运行速度。否则可能会触发“优化回滚”，即编译器已经给这个函数编译成一个函数了，但是突然发现类型变了，有得回滚到通用的状态，然后再重新生成新的函数。

## 第三章 页面优化

- 首先用 JS 做了些逻辑，还触发了样式变化，style 把应用的样式规则计算好之后，把影响到的页面元素进行重新布局（叫做 Layout），再把它画到内存中的一个画布中，Paint 成了像素，最后吧这个画布刷新到屏幕上去，叫做 composite，形成一帧。
- 减少 Layout；能使用 transform 就不要使用 position/width/height 做动画，另外要减少 Layout 的影响范围
- 简化 DOM 结构
- 使用响应式图片 picture img source srcset media source 还可以使用 webp 格式文件
- 一个页面展示太多图片，那么页面的 onloaded 时间将会较长，并且由于并行加载资源数是有限的，图片太多会导致放在 body 后面的 JS 解析比较慢，页面将较长时间处于不可交互状态。所以不能一下子把全部图片都放出来，这对于手机上的流量也是不利的。
- 将 src 的属性写成了 "about: black"。这是因为不能随便写一个不存在的地址，否则控制台会报错：加载失败；如果写成空或者不写。就会认为 src 就是当前页面。如果写成 about: blank，大家相安无事。并且不同浏览器兼容性好。
- gzip 压缩，只需要在 Nginx 的配置里面添加 gzip on  就可以开启压缩了。
- 第一次请求的时候，Nginx 的 http 响应头里面返回了 HTML 的最近修改时间；在第二次请求的时候，浏览器会把这个 Last-Modified 带上，变成 If-Modified-Since 字段；这样 Nginx 就可以读取本地文件信息里的修改时间和这个进行比较，一旦时间一致或者在此之前，返回 304，告诉客户端从缓存中取。
- 手动控制缓存时间，就是使用 Cache-Control。max-age 的优先级要大于 last-modified。如果要强制不缓存，则把 expires 时间改成 0。
- 设置缓存的作用一个是把 200 变成 304，避免资源重新传输，第二个是让浏览器直接从缓存读取，连 http请求都不用了。
- Nginx 开启 etag 只需要在 server 配置里面加上一行， etag on。etag 就是对文件做一个校验和。第一次访问的时候，响应头里面返回这个文件的 etag，浏览器第二次访问的时候，把 etag 带上，添加在 If-None-Match 字段，Nginx 根据这个 etag 和新渲染的文件计算出的 etag 进行比较，如果相等则返回 304。由于 etag 是要使用少数的字符表示一个不定大小的文件，所以 etag 是有重合的风险的。使用 etag 的代价是增加了服务器的计算负担，特别是当文件比较大的时候。

### 用好 Chrome Devtools

- console.table 可以用来查看数组和对象，非常清爽
- console.dir 能递归打印 DOM 对象的所有属性
- 用 %c 可以在控制台打印带样式的提示语 console.log('%c 你颠三倒四 %s', 'background: #222', '>>')
- 检查没有用到的 CSS/JS；打开 devtools 的 Coverage 标签栏，没有用到的用红色表示，用到的用绿色表示；用媒体查询去加载不同的 CSS; `<link ref="stylesheet" href="large.css" media="screen and (min-width:500px)">`
- console.trace 向 Web 控制台输出一个堆栈跟踪
- F10 下一步；F8 跳到下一个断点；command + ; step into 进入函数执行；shift + command/ctrl + ; step out 跳出当前函数

## h5 优化实践

### 使用 h5 的 history 改善 ajax 列表请求

- 当用户单击前进后退按钮会触发 window.onpopstate 事件，window.history.pushState(state, title, url) 其中 state 为一个 object，用来存放当前页面的数据，title 标题没有多大的作用，url 为当前页面的 url，一旦更改这个 url，浏览器地址栏的地址也会发生变化。popState 只能建ring自己调用 push 进去的。如果不是自己 push 的，那么就不会触发 popstate 事件。

### 使用 service Worker 做一个 PWA 离线应用

- 先注册一个 Worker，然后后台就会启动一条线程，可以在这条线程启动的时候去加载一些资源缓存起来，然后监听 fetch 事件，在这个事件里拦截页面的请求，先看下缓存是否有，如果有直接返回，否则正常加载。或者一开始不缓存，每个资源请求后再拷贝一份缓存起来，然后下一次请求的时候缓存里就有了。
- Service Worker 和 Cookie 一样是有 Path 路径概念的，如果设定一个 cookie 为time 的 path=/page/A，在 /page/B 这个页面是不能获取到这个 cookie 的，如果设置 cookie 的 path 为根目录 /，则所有页面都能获取到。类似的，如果注册的时候使用的 js 路径为 /page/sw.js，那么这个 Service Worker 只能管理 /page 路径下的页面和资源，而不能处理 /api 路径下，所以一般吧 Service Worker 注册到顶级目录，这样 Service Worker 就能接管页面的所有资源了。`navigator.serviceWorker.register('/sw-3.js')`

## 第五章 前端与计算机基础

### TCP 三次握手

- 向目标端口发送了一个TCP 包，带上标识位 SYN，表示要建立一个连接，并指明包开始的序列号 seq（单位为字节），以后传送的字节编号都是以这个作为起点。
- 进行回复，发送了一个 SYN + ACK 的报文段，表示同意建立连接。
- 收到 SYN 之后发送一个 ACK，同事改变接收窗口，完成三次握手。

### 接收窗口

— 它根据自身网络情况设置不同大小的值用来控制对方发送速度，避免对方发送太快，导致网络拥塞。

### 关闭连接

- 请求方觉得不用再请求数据了，于是要把连接关闭了，它向响应方发送一个 FIN 的报文。等待 30s 才关闭的是因为 HTTP 请求的 Connection: keep-alive 字段的影响，因为同一个域可能要请求多个资源，不能一个请求完了就把  连接关闭了。人如果不关闭又占用端口号资源，端口号最多只有 65535 个。
- 响应方接收后向请求方发送一个 ACK，这个时候连接出于半关闭的状态，即请求方不能向响应方发送数据了，但是响应方还可以向请求方发送。
- 响应方也要把连接关闭了，于是它向请求方发送 FIN。
- 请求方接收后，就发送 ACK，此时连接完全关闭，然后主动关闭方将进入 TIME_WAIT 状态。

### MSS 和 TIME_WAIT

- TIME_WAIT 时间为 2MSL，MSL 的意思是 Maximum Server Live-time，即报文端的最大生存时间，标准建议为2 分钟，实际实现有的为 30s。在 TIME_WAIT 状态下，上一次建立连接的套接字(socket) 将不可再重新启用，也就是同一个网卡/IP 不可再建立同样端口号的连接，如果再重新创建系统将会报错，主要是为了避免有些报文段在网络上滞留，被对方收到的时候恰好又启用了一个完全一样的套接字，那么就会被认为是这个链接的数据。
- 可以在创建 socket 的时候，指定 SO_REUSEADDR 的选项，这样就不用等待 TIME_WAIT 的时间了。
- 另外还有一个时间叫 RTT（Round Trip Time），即一个报文段的往返时间

### TCP 为什么要握手三次

- 三次握手并不能保证双方完全的信任对方，即使是四次、五次也是同样的道理，至少有一方式无法信任另一方，另外一方一想到对方可能不信它，它也会变得不信对方。

### 为什么挥手要四次

- 前两次挥手让连接出于半关闭状态，此时主动关闭方不可再向被动关闭方发送数据，而被动关闭方可继续向主动关闭方发送数据。

### 四层传输协议

- 物理层(物理帧，带上目的主机的物理地址) -> 网络层(IP/ARP，带上目的主机的 IP 地址) -> 传输层(TCP/UDP，带上目的主机的端口号) -> 应用层(HTTP、SSH、WS，最后应用层收到数据)
- 在广域网是用的 IP 地址进行报文转发，而到了局域网需要靠物理地址发送给对应的主机。IP 是点到点，负责发送到对应的主机，而 TCP 是端到端，即根据端口号，负责发送给对应的应用程序。

### Nagle 算法

- 核心思想是：等数据积累多了再一起发出去，大概等待 200 ms 这样可以提高网络的吞吐量。但是在现代，带宽和速度已经不是太大的问题，如果每个请求都要延迟 200ms，会造成实时性比较差。所以通常是要把 Nagle 算法禁止，可以在创建套接字的时候设置 TCP_NODELAY 标志位。

### Cookie

- 服务可以通过 Set-Cookie 通知客户端设置 cookie，而客户端可以用 Cookie 字段告知服务器现在的 Cookie 数据是怎么样的。

### WebSocket 连接建立

- 首先还是先建立 TCP 连接，完成后客户端发送一个 upgrade 的 HTTP 请求。
- 服务端收到后统一握手，返回 Switching Protocols，连接建立。

### Websocket 和 WebRTC

- websocket 是为了解决实时传送消息的问题，当然也可以传送数据，但是不保证传送的效率和质量，而 WebRTC 可用于可靠地传输音视频数据、文件等。并且可以建立 P2P 连接，不需要服务端进行转发数据。虚拟电话、在线面试等现在很多都是采用 WebRTC 实现。

### 理解 HTTPS 连接的前几毫秒发生了什么

- HTTPS 要解决问题就是中间人攻击。
- 域名污染，当我们访问一个域名时需要先进行域名解析，即向 DNS 服务器请求某个域名的 IP 地址。在经过 DNS 的中间链点可能会抢答，返回给你一个错误的 IP 地址，这个 IP 地址就指向中间人的机器。
- APR 欺骗，广域网的传输用的是 IP 地址，而在局域网用的是物理地址，例如路由器需要知道连接它的设备的物理地址他才可以把数据包给你，它会通过一个 ARP 的广播，向所有设备查询某个 IP 地址的物理地址是多少。

### 弄懂为什么 0.1 + 0.2 不等于 0.3

#### 反码和补码

公式：

- 正数的补码 = 反码
- 负数的补码 = 反码 + 1

> 内存中都是使用补码来计算的

用临界值的计算来举例

- -2   -> 原码 1000 0010 -> 反码 1111 1101 -> 补码 1111 1110
- -126 -> 原码 1111 1110 -> 反码 1000 0001 -> 补码 1000 0010
- 补码的运算结果：1000 0000（该类数字没有原码和补码）

##### Byte 的数据范围

- 最大的正数：0111 1111 -> 2^7 - 1 = 127
- 最大的负数：1000 0000 -> -2^7 = -128

##### 存储结构

- 单精度：符号1位，阶码8位，尾数23位
- 双精度：符号1位，阶码11位，尾数52位

##### 存储方式

一个十进制的小数在进行存储时，首先要将整数部分与小数部分都转换成二进制。然后再整理成类似科学计数法的形式，即移动小数点，使得小数点的左边只有一位，并且只可能为1（因为是二进制），*小数点右侧的部分即为尾数部分*，*移动小数点的位数将会被记录在指数部分中。*

##### 移码

- 对于绝对值大于2的数，这个时候我们向左移动小数点，对应的指数为正数
- 对于一个绝对值小于1的数，这个时候向右移动小数点，对应的指数为负数

以 float 为例，指数的长度是8，原有带符号位的 8 个 bit 的存储范围是 -128~127，也就是说可以记录 -128 次方到 127 次方之间的所有指数值。如果忽略符号位，把它也当做一个数据的存储位，那么范围就是 0~255，我们取这个数的一半作为修正值，即：127，把每次移动小数点后获取的指数值加上 127.

- 小数点向左移动3位，对应的指数为 +3，存入指数部分的值即为 130 的二进制表示
- 小数点向右移动2位，对应的指数为 -2，存入指数部分的值即为 125 的二进制表示

##### 小数在内存中的存储表示

99.9 的二进制表示：1100011.111001100110011001100110011001100110011001101。现在需要将小数点向左移动 6 位，对应的指数值为 +6。此时小数点右侧的位数为 51 位，这些将会被存放在尾数部分，如果使用 double 类型就可以将数据全部记录，但是如果使用 float 类型，由于尾数部分只有 23 位，所以只能记录部分的数据，误差也就产生了！

整理一下，符号位为 0，指数部分 6 + 127 = 133，尾数部分直接丢进去，能装多少装多少，以 float 为例，最终表示为：0 10000101 10001111100110011001100

- JS 能表示的最大整数为 Number.MAX_SAFE_INTEGER，能表示最大正数为 Number.MAX_VALUE。
计算机是使用味精致存储数据的，整数也是同样的道理，整数可以分成短整型、基本型和长整型，占用的存储空间分别为16位、32位和64位。如果操作系统是 32 位的，那么使用长整型将会慢于短整型，应为一个数它需要分两次取。
- 32 位有符号整型的存储方式，第一位 0 表示正数，1 表示负数，剩下的 31 位表示数值，所以 32 位有符号整数最大值为：2 ^ 31 - 1 = 2 147 489 647。
- 十进制的 0.75 可以表示成 7.5 \* 10 ^ -1，同样地在二进制里面，0.75 可以表示成: 0.75 = 1.1 \* 2 ^ -1
- 0.75 用二进制表示：小数部分不停乘 2，得到整数部分正序就是小数的二进制。整数部分不停除以 2，取余逆序就是整数部分的二进制。
- 如果需要更精确的表示，只需要保留更长的有效位数。这也是双精度的 double 比单精度的 float 更精确的原因。
- 浮点数存储：一个二进制浮点数存储分为三部分：1. 符号位 S 2. 指数部分 3.尾数部分
- 任意一个二进制的浮点数 V 可以表示成下面的格式：